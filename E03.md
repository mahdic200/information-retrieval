# E03

# محدودیت های inverted index

## مورد phrase queries

وقتی که میخوایم بجای ی واژه یا واژه ها یک عبارت خاصی رو جست و جو کنیم مانند standford university . این یک عبارت هست ، اما توی inverted index به صورت مجزا پردازش میشه .

آن وقت standford یک posting list برای خودش داره و university یک posting list جدا برای خودش داره .

> [!IMPORTANT] Too many FP
> تعداد FP های زیادی خواهی داشت و باعث کاهش دقت یا precision موتور جست و جوی ما خواهد شد .

### راه حل

طبق گفته ی کتاب دو تا راه حل داریم :

- مورد biword index
- مورد positional index

### مورد biword index

به معنی شاخص دو کلمه ایی ، برای نمونه سه واژه ی friends, romans, countryment میتوانند دو واژه ی دو تکه ایی "friends romans" و "romans countryment" را به وجود بیاورند . و به همین صورت توی متن ، دو به دو و به صورت یک واژه یک واژه رو به جلو اگر بریم ، دو کلمه ایی های گوناگونی ساخته میشن . مانند In this world there is no war به ترتیب اینگونه میشود In this بعدش this world بعدش world there بعدش there is بعدش is no بعدش no war .

توی بایورد ایندکس این دو کلمه ایی ها میشوند term ها یا واژه های ما . و هرکدام یک posting list جدا دارند .

یک ایراد بسیار بزرگش اینه که اندازه ی واژه نامه ی ما یا vocabulary ما بسیار بسیار زیاد میشود .
در این روش ما FP های کمتری خواهیم داشت .

و چون ما شاخصمون رو بایورد انتخاب کردیم کوئری یا متن جست و جوی خودمون رو هم باید biword پردازش بکنیم .

#### چه زمانی FP خواهیم داشت ؟

زمانی که کوئری یا متن جست و جوی شما بیش از ۲ واژه باشد . چند تکه ایی باشه ، مانند «دانشگاه صنعتی شریف» و آنگاه دیگه ما FP های بیشتری خواهیم داشت .

#### راه حل ؟

پس برازش ، بعد از انیکه نتیجه آمد بررسی میکنیم که کدوم متن ها دقیقا شامل عبارت ما هستند .


### مورد extended biwords

عمل part of speech tagging عملی هست که روی متن انجام میدهند و نقش واژه ها رو مشخص میکنند . و بر مبنای یادگیری ماشین هم هست .

حروف اضافه و ربط رو حذف میکنیم و دو واژه ایی های اصلی رو بر میداریم .


برای اینکه FP هارو بیاریم پایین باید موقعیت وازه ها رو در نظر بگیریم که میرسیم به راه حل زیر .
### مورد positional index

درواقع اینها شاخص هایی هستند که میان position اون واژه ها در سند هارو موقع index کردن لحاظ میکنند .

اینجوریه که مثلا شما واژه ی to رو در نظر بگیر ، باز مثل inverted index بردار داره با شماره ، ولی توی این روش علاوه بر بردار خود واژه ، سند هم یک بردار داره که میگه این واژه در کدوم index ها وجود داره .

چجوری ادغام رو در این انجام بدیم ؟

تمام موقعیت های واژه ها نسبت به همدیگه چک میشه . بسیار غیر بهینه است و محاسبات بسیار زیادی داره . برای کوئری هایی که واژه هاش پشت سر هم هستن بسیار نا بهینه است .

شبه کدش رو هم نمینویسم . خودت رو از تو ویدیو ببین .

### مورد combination scheme

مورد biword index و positional index میتوانند به صورت ترکیبی باهم استفاده شوند .
برای نمونه Michael Jackson یک واژه محسوب میشود که positional index خودش رو هم دارد .

# فصل دو

## مورد Dictionary

تفاوت vocabulary و dictionary : وقتی vocabulary هارو که داده ی مارو تشکیل میدن ، ساختار بهشون میدیم و در غالب یک ساختار خاصی این هارو ذخیره میکنیم این تبدیل میشه به یک dictionary .

### دیکشنری با اندازه ی ثابت dictionary as fixed width

خب بنا بر این ما vocabulary خودمون رو در غالب یک ساختمان داده یا درواقع یک آرایه که برای ساده سازی اندازه ی اون رو ثابت در نظر بگیریم ذخیره میکنیم .

پس بنا بر این ، دیکشنری یک آرایه است که هر خانه از آن یک واژه است و علاوه بر اون یک فیلد دیگه داره که بهش میگن frequency که نشون میده این کلمه در چند تا سند تکرار شده و یک اشاره گر هم داره که اشاره میکنه به posting list متناظرش .

بنا بر این هر سلول این آرایه خودش انگار ی struct هست که سه تا خونه داره . واژه ، فرکانس ، و اشاره گر .

پس ما اومدیم برای این vocab که داشتیم یک ساختار تعریف کردیم .

## ساختمان داده هایی که برای جست و جوی واژه به کار میبریم

دو ساختمان داده ی اصلی که برای این کار استفاده میکنیم :

- هش ها
- درخت ها
